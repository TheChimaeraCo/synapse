# Synapse MVP Build Plan (v0.1)

> Concrete, file-by-file build spec for 3 parallel agents.
> MVP only: Telegram + Claude + Convex + Hub UI + Auth + Usage tracking.

---

## 1. Project Structure

```
synapse/
├── package.json
├── tsconfig.json
├── next.config.ts
├── tailwind.config.ts
├── postcss.config.mjs
├── .env.local                          # Local env vars (not committed)
├── convex/
│   ├── _generated/                     # Auto-generated by Convex
│   ├── schema.ts                       # [AGENT 1] MVP schema
│   ├── http.ts                         # [AGENT 3] HTTP endpoints (Telegram webhook)
│   ├── crons.ts                        # [AGENT 1] Scheduled jobs
│   ├── auth.ts                         # [AGENT 1] Auth.js Convex adapter config
│   ├── functions/
│   │   ├── agents.ts                   # [AGENT 1] Agent CRUD
│   │   ├── sessions.ts                 # [AGENT 1] Session management
│   │   ├── messages.ts                 # [AGENT 1] Message CRUD + queries
│   │   ├── users.ts                    # [AGENT 1] User management
│   │   ├── usage.ts                    # [AGENT 1] Usage tracking + budget
│   │   ├── channels.ts                 # [AGENT 1] Channel config
│   │   └── dashboard.ts               # [AGENT 1] Dashboard aggregation queries
│   ├── actions/
│   │   ├── router.ts                   # [AGENT 3] Message processing pipeline
│   │   ├── claude.ts                   # [AGENT 3] Anthropic Claude API calls
│   │   └── telegram.ts                # [AGENT 3] Telegram send/edit messages
│   └── lib/
│       ├── costCalculator.ts           # [AGENT 1] Token cost math
│       └── validators.ts              # [AGENT 1] Shared validation helpers
├── lib/
│   ├── types.ts                        # [SHARED] All TypeScript types
│   ├── utils.ts                        # [SHARED] cn(), formatters
│   ├── convex.ts                       # [AGENT 2] Convex client setup
│   └── auth.ts                         # [AGENT 2] Auth.js config
├── auth.ts                             # [AGENT 2] Auth.js root config (NextAuth)
├── middleware.ts                        # [AGENT 2] Auth middleware
├── app/
│   ├── layout.tsx                      # [AGENT 2] Root layout (providers, dark theme)
│   ├── page.tsx                        # [AGENT 2] Dashboard page
│   ├── globals.css                     # [AGENT 2] Tailwind + dark theme vars
│   ├── providers.tsx                   # [AGENT 2] ConvexProvider + SessionProvider wrapper
│   ├── login/
│   │   └── page.tsx                    # [AGENT 2] Login page
│   ├── register/
│   │   └── page.tsx                    # [AGENT 2] Register page
│   ├── chat/
│   │   ├── page.tsx                    # [AGENT 2] Conversations list
│   │   └── [sessionId]/
│   │       └── page.tsx                # [AGENT 2] Chat conversation view
│   ├── settings/
│   │   └── page.tsx                    # [AGENT 2] Settings (API keys, agent config)
│   └── api/
│       ├── auth/[...nextauth]/
│       │   └── route.ts                # [AGENT 2] Auth.js API route
│       ├── chat/
│       │   └── route.ts               # [AGENT 2] POST /api/chat - server proxy for sending messages
│       └── chat/stream/
│           └── route.ts               # [AGENT 2] GET /api/chat/stream?sessionId= - SSE endpoint
├── components/
│   ├── ui/                             # [AGENT 2] shadcn/ui primitives
│   │   ├── button.tsx
│   │   ├── input.tsx
│   │   ├── card.tsx
│   │   ├── avatar.tsx
│   │   ├── badge.tsx
│   │   ├── dropdown-menu.tsx
│   │   ├── dialog.tsx
│   │   ├── scroll-area.tsx
│   │   ├── separator.tsx
│   │   ├── skeleton.tsx
│   │   ├── textarea.tsx
│   │   └── toast.tsx
│   ├── layout/
│   │   ├── Sidebar.tsx                 # [AGENT 2] App sidebar (conversations list)
│   │   ├── Header.tsx                  # [AGENT 2] Top nav bar
│   │   └── AppShell.tsx                # [AGENT 2] Sidebar + header + main area
│   ├── chat/
│   │   ├── ChatWindow.tsx              # [AGENT 2] Message list + scroll
│   │   ├── MessageBubble.tsx           # [AGENT 2] Single message display
│   │   ├── ChatInput.tsx               # [AGENT 2] Input box + send button
│   │   └── StreamingIndicator.tsx      # [AGENT 2] "Thinking..." / streaming dots
│   ├── dashboard/
│   │   ├── StatsCards.tsx              # [AGENT 2] Usage stats cards
│   │   └── RecentConversations.tsx     # [AGENT 2] Recent chat list
│   └── auth/
│       └── AuthForm.tsx                # [AGENT 2] Shared login/register form
└── public/
    └── favicon.ico
```

### File Ownership

| Owner | Files |
|-------|-------|
| SHARED (create first) | `lib/types.ts`, `lib/utils.ts`, `package.json`, `tsconfig.json`, `tailwind.config.ts`, `convex/schema.ts` |
| Agent 1 (Backend) | `convex/functions/*`, `convex/crons.ts`, `convex/auth.ts`, `convex/lib/*` |
| Agent 2 (Frontend) | `app/*`, `components/*`, `lib/convex.ts`, `lib/auth.ts`, `auth.ts`, `middleware.ts`, `providers.tsx` |
| Agent 3 (Runtime) | `convex/http.ts`, `convex/actions/*` |

---

## 2. Convex Schema (MVP)

File: `convex/schema.ts`

```typescript
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // --- AUTH (Auth.js adapter tables) ---
  authUsers: defineTable({
    name: v.optional(v.string()),
    email: v.string(),
    emailVerified: v.optional(v.number()),
    image: v.optional(v.string()),
    passwordHash: v.optional(v.string()),
    role: v.union(v.literal("owner"), v.literal("admin"), v.literal("user")),
    gatewayId: v.string(),
  })
    .index("by_email", ["email"])
    .index("by_gatewayId", ["gatewayId"]),

  authSessions: defineTable({
    userId: v.id("authUsers"),
    sessionToken: v.string(),
    expires: v.number(),
    gatewayId: v.string(),
  })
    .index("by_sessionToken", ["sessionToken"])
    .index("by_userId", ["userId"]),

  authAccounts: defineTable({
    userId: v.id("authUsers"),
    type: v.string(),
    provider: v.string(),
    providerAccountId: v.string(),
    refresh_token: v.optional(v.string()),
    access_token: v.optional(v.string()),
    expires_at: v.optional(v.number()),
    token_type: v.optional(v.string()),
    scope: v.optional(v.string()),
    id_token: v.optional(v.string()),
    session_state: v.optional(v.string()),
    gatewayId: v.string(),
  })
    .index("by_provider_providerAccountId", ["provider", "providerAccountId"])
    .index("by_userId", ["userId"]),

  // --- GATEWAYS ---
  gateways: defineTable({
    name: v.string(),
    slug: v.string(),
    ownerId: v.id("authUsers"),
    status: v.union(v.literal("active"), v.literal("paused")),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_slug", ["slug"])
    .index("by_ownerId", ["ownerId"]),

  // --- AGENTS ---
  agents: defineTable({
    gatewayId: v.id("gateways"),
    name: v.string(),
    slug: v.string(),
    model: v.string(),                    // "claude-sonnet-4-20250514"
    systemPrompt: v.string(),
    temperature: v.optional(v.number()),
    maxTokens: v.optional(v.number()),
    isActive: v.boolean(),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_gatewayId", ["gatewayId"])
    .index("by_slug_gatewayId", ["slug", "gatewayId"]),

  // --- CHANNELS ---
  channels: defineTable({
    gatewayId: v.id("gateways"),
    platform: v.union(v.literal("telegram"), v.literal("hub")),
    name: v.string(),
    agentId: v.id("agents"),
    isActive: v.boolean(),
    config: v.any(),                      // platform-specific config (botToken ref, chatId, etc.)
    lastActivityAt: v.optional(v.number()),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_gatewayId", ["gatewayId"])
    .index("by_platform", ["platform"])
    .index("by_agentId", ["agentId"]),

  // --- SESSIONS ---
  sessions: defineTable({
    gatewayId: v.id("gateways"),
    agentId: v.id("agents"),
    channelId: v.id("channels"),
    userId: v.optional(v.id("authUsers")),
    externalUserId: v.string(),           // "telegram:12345" or "hub:userId"
    title: v.optional(v.string()),
    status: v.union(
      v.literal("active"),
      v.literal("archived")
    ),
    lastMessageAt: v.number(),
    messageCount: v.number(),
    createdAt: v.number(),
  })
    .index("by_gatewayId", ["gatewayId"])
    .index("by_channel_externalUser", ["channelId", "externalUserId"])
    .index("by_agentId", ["agentId"])
    .index("by_userId", ["userId"])
    .index("by_status_lastMessage", ["status", "lastMessageAt"]),

  // --- MESSAGES ---
  messages: defineTable({
    gatewayId: v.id("gateways"),
    sessionId: v.id("sessions"),
    agentId: v.id("agents"),
    role: v.union(
      v.literal("user"),
      v.literal("assistant"),
      v.literal("system")
    ),
    content: v.string(),
    tokens: v.optional(v.object({
      input: v.number(),
      output: v.number(),
    })),
    cost: v.optional(v.number()),
    model: v.optional(v.string()),
    latencyMs: v.optional(v.number()),
    channelMessageId: v.optional(v.string()),  // external message ID (telegram msg id)
  })
    .index("by_sessionId", ["sessionId"])
    .index("by_session_time", ["sessionId", "_creationTime"])
    .index("by_gatewayId", ["gatewayId"]),

  // --- ACTIVE RUNS (for streaming state) ---
  activeRuns: defineTable({
    gatewayId: v.id("gateways"),
    sessionId: v.id("sessions"),
    status: v.union(
      v.literal("thinking"),
      v.literal("streaming"),
      v.literal("complete"),
      v.literal("error")
    ),
    streamedContent: v.optional(v.string()),
    error: v.optional(v.string()),
    startedAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_sessionId", ["sessionId"]),

  // --- USAGE RECORDS ---
  usageRecords: defineTable({
    gatewayId: v.id("gateways"),
    agentId: v.id("agents"),
    sessionId: v.optional(v.id("sessions")),
    messageId: v.optional(v.id("messages")),
    userId: v.optional(v.id("authUsers")),
    model: v.string(),
    inputTokens: v.number(),
    outputTokens: v.number(),
    cost: v.number(),
    date: v.string(),                     // "2026-02-11" for daily aggregation
  })
    .index("by_gatewayId_date", ["gatewayId", "date"])
    .index("by_agentId_date", ["agentId", "date"])
    .index("by_date", ["date"]),

  // --- USAGE BUDGETS ---
  usageBudgets: defineTable({
    gatewayId: v.id("gateways"),
    period: v.union(v.literal("daily"), v.literal("monthly")),
    limitUsd: v.number(),
    action: v.union(v.literal("warn"), v.literal("block")),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("by_gatewayId", ["gatewayId"]),

  // --- CHANNEL MESSAGES (raw audit trail) ---
  channelMessages: defineTable({
    gatewayId: v.id("gateways"),
    channelId: v.id("channels"),
    direction: v.union(v.literal("inbound"), v.literal("outbound")),
    rawPayload: v.any(),
    messageId: v.optional(v.id("messages")),
    status: v.union(
      v.literal("received"),
      v.literal("processed"),
      v.literal("sent"),
      v.literal("failed")
    ),
    error: v.optional(v.string()),
  })
    .index("by_channelId", ["channelId"])
    .index("by_status", ["status"]),
});
```

---

## 3. Shared Types (`lib/types.ts`)

```typescript
// ============================================================
// lib/types.ts - Shared types across frontend + backend
// ============================================================

import type { Id } from "../convex/_generated/dataModel";

// --- API Request/Response Contracts ---

/** POST /api/chat - Send a message from Hub */
export interface SendMessageRequest {
  sessionId: string;             // Convex session ID
  content: string;
  gatewayId: string;
}

export interface SendMessageResponse {
  messageId: string;
  sessionId: string;
}

/** GET /api/chat/stream?sessionId=X - SSE stream */
// SSE events:
// event: status   data: { status: "thinking" | "streaming" | "complete" | "error" }
// event: chunk    data: { content: string }
// event: done     data: { messageId: string, tokens: TokenUsage, cost: number }
// event: error    data: { message: string }

// --- Domain Types ---

export interface TokenUsage {
  input: number;
  output: number;
}

export interface MessageDisplay {
  _id: string;
  role: "user" | "assistant" | "system";
  content: string;
  tokens?: TokenUsage;
  cost?: number;
  model?: string;
  latencyMs?: number;
  _creationTime: number;
}

export interface SessionDisplay {
  _id: string;
  title?: string;
  status: "active" | "archived";
  lastMessageAt: number;
  messageCount: number;
  agentName: string;
  channelPlatform: string;
}

export interface AgentConfig {
  _id: string;
  name: string;
  slug: string;
  model: string;
  systemPrompt: string;
  temperature?: number;
  maxTokens?: number;
  isActive: boolean;
}

export interface UsageSummary {
  totalInputTokens: number;
  totalOutputTokens: number;
  totalCost: number;
  messageCount: number;
  period: string;               // "today" | "this_week" | "this_month"
}

export interface DashboardStats {
  totalMessages: number;
  totalCost: number;
  totalSessions: number;
  activeSessions: number;
  todayMessages: number;
  todayCost: number;
}

export interface StreamEvent {
  type: "status" | "chunk" | "done" | "error";
  data: Record<string, unknown>;
}

// --- Telegram Types (for Agent 3) ---

export interface TelegramUpdate {
  update_id: number;
  message?: {
    message_id: number;
    from?: {
      id: number;
      is_bot: boolean;
      first_name: string;
      last_name?: string;
      username?: string;
    };
    chat: {
      id: number;
      type: string;
      title?: string;
    };
    date: number;
    text?: string;
  };
}

export interface NormalizedInbound {
  platform: "telegram" | "hub";
  externalUserId: string;
  externalChatId: string;
  externalMessageId: string;
  displayName: string;
  text: string;
  isGroup: boolean;
  timestamp: number;
}

// --- Claude Types (for Agent 3) ---

export interface ClaudeRequest {
  model: string;
  systemPrompt: string;
  messages: Array<{ role: "user" | "assistant"; content: string }>;
  maxTokens: number;
  temperature?: number;
}

export interface ClaudeResponse {
  content: string;
  usage: TokenUsage;
  model: string;
  stopReason: string;
}

// --- Cost Constants ---

export const MODEL_COSTS: Record<string, { inputPerMillion: number; outputPerMillion: number }> = {
  "claude-sonnet-4-20250514": { inputPerMillion: 3, outputPerMillion: 15 },
  "claude-opus-4-20250514": { inputPerMillion: 15, outputPerMillion: 75 },
  "claude-haiku-3-20250514": { inputPerMillion: 0.25, outputPerMillion: 1.25 },
};
```

---

## 4. Agent Assignments

---

### Agent 1 - Backend (Convex Functions)

**Responsibility:** All Convex queries, mutations, crons, auth adapter, cost calculation. Agent 1 owns the data layer.

#### File: `convex/schema.ts`
Create the full schema exactly as defined in Section 2 above.

#### File: `convex/lib/costCalculator.ts`

```typescript
// calculateCost(model: string, inputTokens: number, outputTokens: number): number
// Returns USD cost. Uses hardcoded MODEL_COSTS map.
// Formula: (inputTokens / 1_000_000 * inputRate) + (outputTokens / 1_000_000 * outputRate)
```

#### File: `convex/lib/validators.ts`

```typescript
// validateGatewayAccess(ctx, userId, gatewayId): Promise<void>
//   - Verify user owns or has access to gateway. Throws on failure.
//
// validateOwnership(ctx, docId, gatewayId): Promise<Doc>
//   - Get document, verify gatewayId matches. Throws on mismatch. Returns doc.
```

#### File: `convex/functions/agents.ts`

All functions take `gatewayId` and validate access.

| Function | Type | Args | Returns | Behavior |
|----------|------|------|---------|----------|
| `list` | query | `{ gatewayId }` | `Agent[]` | List all agents for gateway |
| `get` | query | `{ id }` | `Agent` | Get single agent |
| `create` | mutation | `{ gatewayId, name, slug, model, systemPrompt, temperature?, maxTokens? }` | `Id<"agents">` | Create agent, set `isActive: true`, timestamps |
| `update` | mutation | `{ id, name?, model?, systemPrompt?, temperature?, maxTokens?, isActive? }` | `void` | Patch agent, validate gateway ownership |
| `remove` | mutation | `{ id }` | `void` | Delete agent (and warn if channels reference it) |

#### File: `convex/functions/sessions.ts`

| Function | Type | Args | Returns | Behavior |
|----------|------|------|---------|----------|
| `list` | query | `{ gatewayId, status?, limit? }` | `SessionDisplay[]` | List sessions with agent name joined. Default limit 50. Order by `lastMessageAt` desc. |
| `get` | query | `{ id }` | `Session` | Get single session |
| `listByUser` | query | `{ userId, gatewayId }` | `SessionDisplay[]` | Sessions for a specific Hub user |
| `findOrCreate` | mutation | `{ gatewayId, agentId, channelId, externalUserId, userId? }` | `Id<"sessions">` | Find by `channelId + externalUserId`. If found and active, return it. If not found, create with `status: "active"`, `messageCount: 0`, `lastMessageAt: Date.now()`. |
| `archive` | mutation | `{ id }` | `void` | Set status to "archived" |
| `updateLastMessage` | mutation (internal) | `{ id }` | `void` | Increment messageCount, set lastMessageAt to now |

#### File: `convex/functions/messages.ts`

| Function | Type | Args | Returns | Behavior |
|----------|------|------|---------|----------|
| `list` | query | `{ sessionId, limit?, cursor? }` | `{ messages: MessageDisplay[], cursor? }` | Paginated, ordered by `_creationTime` asc. Default limit 50. |
| `getRecent` | query | `{ sessionId, limit }` | `MessageDisplay[]` | Last N messages for context building. Ordered asc. |
| `create` | mutation | `{ gatewayId, sessionId, agentId, role, content, tokens?, cost?, model?, latencyMs?, channelMessageId? }` | `Id<"messages">` | Insert message. Call `sessions.updateLastMessage` internally. |
| `getById` | query | `{ id }` | `Message` | Single message |

#### File: `convex/functions/users.ts`

| Function | Type | Args | Returns | Behavior |
|----------|------|------|---------|----------|
| `getByEmail` | query | `{ email }` | `AuthUser or null` | Lookup for auth |
| `create` | mutation | `{ email, name, passwordHash, role, gatewayId }` | `Id<"authUsers">` | Create user. Default role "user". |
| `get` | query | `{ id }` | `AuthUser` | Get by ID |
| `updateProfile` | mutation | `{ id, name?, email? }` | `void` | Update profile fields |

#### File: `convex/functions/channels.ts`

| Function | Type | Args | Returns | Behavior |
|----------|------|------|---------|----------|
| `list` | query | `{ gatewayId }` | `Channel[]` | All channels for gateway |
| `get` | query | `{ id }` | `Channel` | Single channel |
| `getByPlatform` | query | `{ gatewayId, platform }` | `Channel or null` | Find channel by platform |
| `create` | mutation | `{ gatewayId, platform, name, agentId, config }` | `Id<"channels">` | Create channel |
| `update` | mutation | `{ id, name?, agentId?, config?, isActive? }` | `void` | Update channel |

#### File: `convex/functions/usage.ts`

| Function | Type | Args | Returns | Behavior |
|----------|------|------|---------|----------|
| `record` | mutation | `{ gatewayId, agentId, sessionId?, messageId?, userId?, model, inputTokens, outputTokens, cost }` | `Id<"usageRecords">` | Insert record. `date` auto-set to today's ISO date string. |
| `getTodaySummary` | query | `{ gatewayId }` | `UsageSummary` | Aggregate today's usage for gateway |
| `getDateRange` | query | `{ gatewayId, startDate, endDate }` | `UsageSummary` | Aggregate usage over date range |
| `checkBudget` | query | `{ gatewayId }` | `{ allowed: boolean, action?: string, remainingUsd?: number }` | Check today's spend against daily budget. Check month spend against monthly budget. Return worst result. |
| `getBudget` | query | `{ gatewayId }` | `UsageBudget or null` | Get budget config |
| `setBudget` | mutation | `{ gatewayId, period, limitUsd, action }` | `Id<"usageBudgets">` | Upsert budget |

#### File: `convex/functions/dashboard.ts`

| Function | Type | Args | Returns | Behavior |
|----------|------|------|---------|----------|
| `getStats` | query | `{ gatewayId }` | `DashboardStats` | Aggregate: total messages, cost, sessions, active sessions, today's messages, today's cost |
| `getRecentSessions` | query | `{ gatewayId, limit? }` | `SessionDisplay[]` | Last N sessions with agent name. Default 10. |

#### File: `convex/functions/activeRuns.ts`

| Function | Type | Args | Returns | Behavior |
|----------|------|------|---------|----------|
| `get` | query | `{ sessionId }` | `ActiveRun or null` | Get active run for session |
| `create` | mutation (internal) | `{ gatewayId, sessionId, status }` | `Id<"activeRuns">` | Create run entry |
| `updateStatus` | mutation (internal) | `{ id, status, streamedContent?, error? }` | `void` | Update run status/content |
| `appendStream` | mutation (internal) | `{ id, chunk }` | `void` | Append chunk to `streamedContent` |
| `complete` | mutation (internal) | `{ id }` | `void` | Set status "complete", then delete after 5s via scheduler |

#### File: `convex/crons.ts`

```typescript
import { cronJobs } from "convex/server";
const crons = cronJobs();

// Archive stale sessions (no activity for 24h)
crons.interval("cleanup-stale-sessions", { hours: 1 },
  internal.functions.sessions.cleanupStale  // sets status="archived" where lastMessageAt < 24h ago
);

export default crons;
```

#### File: `convex/auth.ts`

This is NOT an Auth.js adapter file. This file contains Convex functions that the Auth.js adapter in the Next.js app calls via HTTP. However, for the MVP, we use a simpler approach:

Auth.js runs entirely in Next.js. It uses the Convex HTTP client to read/write auth tables. The Auth.js adapter calls Convex mutations/queries via `fetchQuery`/`fetchMutation` from `convex/browser`.

**Agent 1 must expose these internal functions for auth:**

| Function | Type | Args | Returns | Behavior |
|----------|------|------|---------|----------|
| `auth.getUserByEmail` | query (internal) | `{ email }` | `AuthUser or null` | For credentials login |
| `auth.createUser` | mutation (internal) | `{ email, name, passwordHash, role, gatewayId }` | `Id<"authUsers">` | For registration |
| `auth.getSession` | query (internal) | `{ sessionToken }` | `{ session, user } or null` | Session lookup |
| `auth.createSession` | mutation (internal) | `{ userId, sessionToken, expires }` | `Id<"authSessions">` | Create session |
| `auth.deleteSession` | mutation (internal) | `{ sessionToken }` | `void` | Logout |

---

### Agent 2 - Hub UI (Next.js Frontend)

**Responsibility:** All Next.js pages, components, auth config, server-side Convex proxy routes. The browser NEVER talks to Convex directly for mutations - all writes go through Next.js API routes. Reads use Convex React hooks (useQuery) for real-time subscriptions.

#### Auth Setup

**File: `auth.ts` (project root)**
```typescript
// NextAuth v5 config
// Providers: Credentials (email + password)
// Adapter: Custom Convex adapter (calls convex functions via ConvexHttpClient)
// Session strategy: "jwt"
// Callbacks:
//   - jwt: attach userId, role, gatewayId to token
//   - session: expose userId, role, gatewayId on session object
// Pages:
//   - signIn: "/login"
//   - newUser: "/register"
```

**File: `middleware.ts`**
```typescript
// Protect all routes except /login, /register, /api/auth
// Redirect unauthenticated users to /login
// Use auth() from next-auth/middleware
```

**File: `lib/auth.ts`**
```typescript
// Export: auth, signIn, signOut, handlers from auth.ts root config
// Export: getServerSession helper for API routes
```

**File: `lib/convex.ts`**
```typescript
// ConvexHttpClient for server-side use in API routes
// ConvexReactClient setup for client-side useQuery
// Export: convexClient (server), ConvexClientProvider (client wrapper)
```

#### Providers

**File: `app/providers.tsx`**
```typescript
// "use client"
// Wraps children in:
//   1. SessionProvider (Auth.js)
//   2. ConvexProvider (Convex React)
// Gets convex URL from env: NEXT_PUBLIC_CONVEX_URL
```

#### Layout

**File: `app/layout.tsx`**
```typescript
// Root layout with:
// - <html className="dark"> (always dark mode)
// - Inter font
// - Providers wrapper
// - AppShell (sidebar + header + main)
// - Toaster
```

**File: `app/globals.css`**
```css
/* Tailwind v4 imports */
/* Dark theme CSS variables:
   --background: zinc-950
   --foreground: zinc-50
   --card: zinc-900
   --primary: blue-500
   --accent: purple-500
   --muted: zinc-400
   --border: zinc-800
*/
```

#### Components

**`components/layout/AppShell.tsx`**
- Sidebar on left (280px), collapsible on mobile
- Header on top with user avatar dropdown (logout)
- Main content area

**`components/layout/Sidebar.tsx`**
- Logo/brand at top
- Nav links: Dashboard, Chat, Settings
- Conversations list (uses `useQuery(api.functions.sessions.list)`)
- Each conversation shows: title or "Untitled", last message time, message count
- Active conversation highlighted
- "New Chat" button at top

**`components/layout/Header.tsx`**
- Page title (dynamic based on route)
- User avatar + name on right
- Dropdown: Settings, Logout

**`components/chat/ChatWindow.tsx`**
- Props: `sessionId: string`
- Uses `useQuery(api.functions.messages.list, { sessionId })` for messages
- Uses `useQuery(api.functions.activeRuns.get, { sessionId })` for streaming state
- Auto-scrolls to bottom on new messages
- Renders `MessageBubble` for each message
- Renders `StreamingIndicator` when activeRun exists

**`components/chat/MessageBubble.tsx`**
- Props: `message: MessageDisplay`
- User messages: right-aligned, blue-ish background
- Assistant messages: left-aligned, zinc-800 background
- Renders markdown content (use `react-markdown` with `remark-gfm`)
- Shows timestamp on hover
- Shows token count + cost on hover for assistant messages

**`components/chat/ChatInput.tsx`**
- Textarea with send button
- Ctrl+Enter or button click to send
- Calls `POST /api/chat` with `{ sessionId, content, gatewayId }`
- Disabled while activeRun is in progress
- Auto-focus on mount

**`components/chat/StreamingIndicator.tsx`**
- Props: `activeRun: ActiveRun`
- Shows "Thinking..." with pulse animation when status is "thinking"
- Shows streaming content with blinking cursor when status is "streaming"
- Renders markdown for streamed content

**`components/dashboard/StatsCards.tsx`**
- Props: `stats: DashboardStats`
- 4 cards in a grid: Total Messages, Total Cost, Active Sessions, Today's Cost
- Each card: icon, label, value

**`components/dashboard/RecentConversations.tsx`**
- Props: `sessions: SessionDisplay[]`
- List of recent conversations with title, time, message count, agent name
- Click navigates to `/chat/[sessionId]`

**`components/auth/AuthForm.tsx`**
- Props: `mode: "login" | "register"`
- Email + password fields
- Submit calls `signIn("credentials", ...)` for login
- Submit calls `POST /api/auth/register` then `signIn` for register
- Error display
- Link to switch between login/register

#### Pages

**`app/page.tsx` (Dashboard)**
- Server component, redirects to /login if no session
- Uses `useQuery(api.functions.dashboard.getStats, { gatewayId })`
- Uses `useQuery(api.functions.dashboard.getRecentSessions, { gatewayId })`
- Renders StatsCards + RecentConversations

**`app/login/page.tsx`**
- AuthForm with mode="login"
- Redirect to / if already authenticated

**`app/register/page.tsx`**
- AuthForm with mode="register"
- On success, auto-login and redirect to /

**`app/chat/page.tsx`**
- Conversations list (full page version, also in sidebar)
- "New Chat" button that creates a session and navigates to it

**`app/chat/[sessionId]/page.tsx`**
- ChatWindow + ChatInput
- Load session info in header
- 404 if session doesn't exist or wrong gateway

**`app/settings/page.tsx`**
- Agent configuration section:
  - Name, model dropdown, system prompt textarea, temperature slider, max tokens
  - Save button calls `POST /api/settings/agent` (proxy to Convex mutation)
- Usage budget section:
  - Daily limit, monthly limit, action on exceed
  - Save calls Convex mutation via API route
- API Keys display (env vars, read-only display of what's configured)

#### API Routes (Server-side Convex Proxy)

**`app/api/chat/route.ts` - POST**
```typescript
// 1. Verify auth session (getServerSession)
// 2. Parse body: { sessionId, content, gatewayId }
// 3. Validate user has access to gatewayId
// 4. Call convex mutation: messages.create({ role: "user", content, ... })
// 5. Call convex action: router.processMessage({ sessionId, gatewayId })
//    (This triggers the agent loop - Agent 3's code)
// 6. Return { messageId, sessionId }
```

**`app/api/chat/stream/route.ts` - GET (SSE)**
```typescript
// 1. Verify auth session
// 2. Get sessionId from query params
// 3. Subscribe to activeRuns for this session (poll Convex query every 500ms)
// 4. Stream SSE events:
//    - status changes
//    - content chunks (diff from last sent)
//    - done event with final message details
// 5. Close stream when run completes
// Note: This is a polling-based SSE bridge. The frontend can also use
//       useQuery(api.functions.activeRuns.get) directly for real-time via Convex.
//       This SSE endpoint is an alternative for non-Convex clients.
```

**`app/api/auth/register/route.ts` - POST**
```typescript
// 1. Parse body: { email, password, name }
// 2. Validate email format, password strength (min 8 chars)
// 3. Check if email exists (convex query)
// 4. Hash password with bcrypt (cost 12)
// 5. Create user via convex mutation
// 6. Create default gateway for user
// 7. Create default agent for gateway
// 8. Create hub channel for gateway
// 9. Return { success: true }
```

**`app/api/settings/agent/route.ts` - POST**
```typescript
// 1. Verify auth
// 2. Parse body: AgentConfig fields
// 3. Call convex mutation agents.update
// 4. Return updated agent
```

---

### Agent 3 - Channels + Runtime (Telegram + Agent Loop)

**Responsibility:** Telegram webhook handling, Claude API integration, message processing pipeline, streaming to Convex. Agent 3 is the "brain" that connects channels to AI.

#### File: `convex/http.ts`

```typescript
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";

const http = httpRouter();

// Telegram webhook endpoint
http.route({
  path: "/webhook/telegram",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    // 1. Verify webhook secret from X-Telegram-Bot-Api-Secret-Token header
    //    Compare against TELEGRAM_WEBHOOK_SECRET env var
    // 2. Parse JSON body as TelegramUpdate
    // 3. Ignore non-message updates (edited, callback_query, etc. for MVP)
    // 4. Ignore messages without text
    // 5. Store raw payload:
    //    ctx.runMutation(internal.functions.channelMessages.store, { ... })
    // 6. Schedule processing (non-blocking):
    //    ctx.scheduler.runAfter(0, internal.actions.router.processInbound, {
    //      platform: "telegram",
    //      payload: body,
    //    })
    // 7. Return 200 OK immediately
    return new Response("OK", { status: 200 });
  }),
});

// Hub chat endpoint (for sending messages from Hub via direct Convex call)
// Not needed - Hub uses API routes that call Convex mutations directly.
// But we need an HTTP endpoint for the Hub to trigger the agent loop:
http.route({
  path: "/hub/send",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    // 1. Verify auth token from Authorization header
    // 2. Parse body: { sessionId, gatewayId, messageId }
    //    (message already created by API route, this just triggers processing)
    // 3. Schedule: ctx.scheduler.runAfter(0, internal.actions.router.processSession, { sessionId, gatewayId })
    // 4. Return 200
    return new Response("OK", { status: 200 });
  }),
});

export default http;
```

#### File: `convex/actions/router.ts`

This is the core message processing pipeline.

```typescript
// === processInbound ===
// Type: internalAction
// Args: { platform: "telegram", payload: TelegramUpdate }
// Behavior:
//   1. Parse payload into NormalizedInbound using parseTelegram()
//   2. Find channel: query channels.getByPlatform({ gatewayId: DEFAULT_GATEWAY, platform: "telegram" })
//      For MVP, use a single hardcoded gateway. Multi-tenant routing comes later.
//   3. Find or create session: mutation sessions.findOrCreate({
//        gatewayId, agentId: channel.agentId, channelId: channel._id,
//        externalUserId: `telegram:${inbound.externalUserId}`
//      })
//   4. Store user message: mutation messages.create({
//        gatewayId, sessionId, agentId, role: "user", content: inbound.text,
//        channelMessageId: inbound.externalMessageId
//      })
//   5. Check budget: query usage.checkBudget({ gatewayId })
//      If not allowed and action is "block":
//        Send telegram message "Usage limit reached" and return
//   6. Create activeRun: mutation activeRuns.create({ gatewayId, sessionId, status: "thinking" })
//   7. Get agent config: query agents.get({ id: channel.agentId })
//   8. Get recent messages for context: query messages.getRecent({ sessionId, limit: 15 })
//   9. Build Claude messages array from recent messages
//  10. Call Claude: action claude.chat({
//        model: agent.model,
//        systemPrompt: agent.systemPrompt,
//        messages: claudeMessages,
//        maxTokens: agent.maxTokens || 4096,
//        temperature: agent.temperature
//      })
//      This returns the full response (non-streaming for Telegram in MVP).
//  11. Store assistant message: mutation messages.create({
//        gatewayId, sessionId, agentId, role: "assistant", content: response.content,
//        tokens: response.usage, cost: calculateCost(...), model: response.model, latencyMs
//      })
//  12. Send to Telegram: action telegram.sendMessage({
//        chatId: inbound.externalChatId,
//        text: response.content,
//        replyToMessageId: parseInt(inbound.externalMessageId)
//      })
//  13. Record usage: mutation usage.record({ ... })
//  14. Complete run: mutation activeRuns.complete({ id: runId })

// === processSession ===
// Type: internalAction
// Args: { sessionId, gatewayId }
// Behavior:
//   Same as processInbound steps 5-14, but:
//   - Session already exists (passed in)
//   - User message already stored (by Hub API route)
//   - No Telegram send at the end
//   - Instead, streaming: update activeRun with chunks as they arrive from Claude
//   For Hub, we DO stream:
//     1. Create activeRun with status "thinking"
//     2. Call Claude with streaming enabled
//     3. As chunks arrive, call mutation activeRuns.appendStream({ id, chunk })
//     4. Update status to "streaming" on first chunk
//     5. On complete, store final message, record usage, set run to "complete"
//   The Hub frontend subscribes to activeRuns via useQuery and renders in real-time.
```

**Helper: `parseTelegram(payload: TelegramUpdate): NormalizedInbound`**
```typescript
// Extract from Telegram update:
//   externalUserId: String(message.from.id)
//   externalChatId: String(message.chat.id)
//   externalMessageId: String(message.message_id)
//   displayName: message.from.first_name + (message.from.last_name || "")
//   text: message.text
//   isGroup: message.chat.type !== "private"
//   timestamp: message.date * 1000
```

#### File: `convex/actions/claude.ts`

```typescript
// === chat ===
// Type: internalAction
// Args: ClaudeRequest { model, systemPrompt, messages, maxTokens, temperature? }
// Returns: ClaudeResponse { content, usage, model, stopReason }
// Behavior:
//   1. Get ANTHROPIC_API_KEY from process.env
//   2. Call Anthropic API:
//      POST https://api.anthropic.com/v1/messages
//      Headers: x-api-key, anthropic-version: "2023-06-01", content-type: application/json
//      Body: { model, system: systemPrompt, messages, max_tokens: maxTokens, temperature }
//   3. Parse response
//   4. Return { content: response.content[0].text, usage: { input: response.usage.input_tokens, output: response.usage.output_tokens }, model, stopReason: response.stop_reason }

// === chatStream ===
// Type: internalAction
// Args: ClaudeRequest + { runId: Id<"activeRuns"> }
// Returns: ClaudeResponse
// Behavior:
//   1. Same setup as chat
//   2. Add stream: true to request body
//   3. Read SSE stream from Anthropic
//   4. On each content_block_delta event:
//      - Call ctx.runMutation(internal.functions.activeRuns.appendStream, { id: runId, chunk: delta.text })
//   5. On message_stop: collect final usage, return ClaudeResponse
//   Note: Use fetch() directly with ReadableStream for streaming.
//   The Anthropic SDK can also be used: `anthropic.messages.stream()`
```

#### File: `convex/actions/telegram.ts`

```typescript
// === sendMessage ===
// Type: internalAction
// Args: { chatId: string, text: string, replyToMessageId?: number, parseMode?: string }
// Returns: { ok: boolean, messageId?: number, error?: string }
// Behavior:
//   1. Get TELEGRAM_BOT_TOKEN from process.env
//   2. POST https://api.telegram.org/bot{token}/sendMessage
//      Body: { chat_id: chatId, text, reply_to_message_id: replyToMessageId, parse_mode: parseMode || "Markdown" }
//   3. If text > 4096 chars, split into chunks and send multiple messages
//   4. Return result

// === editMessage ===
// Type: internalAction
// Args: { chatId: string, messageId: number, text: string, parseMode?: string }
// Returns: { ok: boolean }
// Behavior:
//   1. POST https://api.telegram.org/bot{token}/editMessageText
//      Body: { chat_id: chatId, message_id: messageId, text, parse_mode: parseMode || "Markdown" }
//   2. Return result
//   Used for streaming updates on Telegram (Phase 2 - not MVP).
```

---

## 5. Integration Points

### How Agents Call Each Other's Code

```
Agent 2 (Hub Frontend)
  |
  | POST /api/chat { sessionId, content, gatewayId }
  |
  v
API Route (app/api/chat/route.ts)
  |
  | 1. convexClient.mutation(api.functions.messages.create, { ... })  [Agent 1's code]
  | 2. convexClient.action(internal.actions.router.processSession, { ... })  [Agent 3's code]
  |    OR: fetch(`${CONVEX_SITE_URL}/hub/send`, { ... })  [Agent 3's HTTP endpoint]
  |
  v
Agent 3 (router.processSession)
  |
  | 1. ctx.runQuery(api.functions.usage.checkBudget, { ... })         [Agent 1's code]
  | 2. ctx.runQuery(api.functions.agents.get, { ... })                [Agent 1's code]
  | 3. ctx.runQuery(api.functions.messages.getRecent, { ... })        [Agent 1's code]
  | 4. ctx.runAction(internal.actions.claude.chatStream, { ... })     [Agent 3's own code]
  | 5. ctx.runMutation(api.functions.messages.create, { ... })        [Agent 1's code]
  | 6. ctx.runMutation(api.functions.usage.record, { ... })           [Agent 1's code]
  | 7. ctx.runMutation(internal.functions.activeRuns.appendStream)    [Agent 1's code]
```

```
Telegram Webhook
  |
  | POST /webhook/telegram
  |
  v
Agent 3 (http.ts handler)
  |
  | ctx.scheduler.runAfter(0, internal.actions.router.processInbound, { ... })
  |
  v
Agent 3 (router.processInbound)
  |
  | Same flow as processSession, but:
  | - Creates the user message itself
  | - Sends response via telegram.sendMessage instead of streaming
  | - Uses claude.chat (non-streaming) instead of claude.chatStream
```

### Real-time Data Flow (Hub)

```
Convex DB (messages table)  <-- Agent 3 writes messages
  |
  | Convex subscription (automatic push)
  |
  v
useQuery(api.functions.messages.list)  <-- Agent 2's React component
  |
  v
ChatWindow re-renders with new message

Convex DB (activeRuns table)  <-- Agent 3 writes stream chunks
  |
  | Convex subscription
  |
  v
useQuery(api.functions.activeRuns.get)  <-- Agent 2's React component
  |
  v
StreamingIndicator shows live content
```

### Environment Variables

All agents must agree on these. Set in `.env.local` (Next.js) and Convex dashboard (Convex env vars).

**Next.js `.env.local`:**
```
NEXT_PUBLIC_CONVEX_URL=https://your-deployment.convex.cloud
CONVEX_DEPLOY_KEY=your-convex-deploy-key
NEXTAUTH_SECRET=random-32-char-secret
NEXTAUTH_URL=http://localhost:3000
```

**Convex Environment Variables (set via `npx convex env set`):**
```
ANTHROPIC_API_KEY=sk-ant-...
TELEGRAM_BOT_TOKEN=123456:ABC-DEF...
TELEGRAM_WEBHOOK_SECRET=random-secret-for-verifying-webhooks
DEFAULT_GATEWAY_ID=<set after first gateway is created>
```

### Shared API Route Contracts

| Endpoint | Method | Auth | Request Body | Response | Called By |
|----------|--------|------|-------------|----------|-----------|
| `/api/chat` | POST | JWT session | `SendMessageRequest` | `SendMessageResponse` | Hub ChatInput |
| `/api/auth/register` | POST | None | `{ email, password, name }` | `{ success: boolean }` | Register page |
| `/api/settings/agent` | POST | JWT session | Partial `AgentConfig` | `AgentConfig` | Settings page |
| `/webhook/telegram` | POST | Telegram secret header | `TelegramUpdate` | `"OK"` (200) | Telegram servers |
| `/hub/send` | POST | Bearer token | `{ sessionId, gatewayId }` | `"OK"` (200) | Hub API route |

---

## 6. Dependencies

**`package.json`:**

```json
{
  "name": "synapse",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "convex:dev": "npx convex dev",
    "convex:deploy": "npx convex deploy"
  },
  "dependencies": {
    "next": "^15.1.0",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "convex": "^1.17.0",
    "next-auth": "^5.0.0-beta.25",
    "@auth/core": "^0.37.0",
    "bcryptjs": "^2.4.3",
    "react-markdown": "^9.0.0",
    "remark-gfm": "^4.0.0",
    "lucide-react": "^0.460.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.6.0",
    "class-variance-authority": "^0.7.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-dialog": "^1.1.0",
    "@radix-ui/react-dropdown-menu": "^2.1.0",
    "@radix-ui/react-scroll-area": "^1.2.0",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-avatar": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.0"
  },
  "devDependencies": {
    "typescript": "^5.7.0",
    "@types/node": "^22.0.0",
    "@types/react": "^19.0.0",
    "@types/bcryptjs": "^2.4.0",
    "tailwindcss": "^4.0.0",
    "@tailwindcss/postcss": "^4.0.0",
    "postcss": "^8.4.0"
  }
}
```

---

## 7. Build Order

### Phase 0: Scaffolding (Sequential, before agents start)

1. `npx create-next-app@latest synapse --typescript --tailwind --app --src=false`
2. `cd synapse && npx convex init`
3. Install all dependencies from package.json
4. Create `lib/types.ts` (shared types - copy from Section 3)
5. Create `lib/utils.ts` (cn helper)
6. Create `convex/schema.ts` (copy from Section 2)
7. Run `npx convex dev` to validate schema and generate types
8. Set Convex environment variables
9. Initialize shadcn/ui: `npx shadcn@latest init`
10. Add shadcn components: button, input, card, avatar, badge, dropdown-menu, dialog, scroll-area, separator, skeleton, textarea, toast

### Phase 1: Parallel Build (All 3 agents work simultaneously)

```
Agent 1 (Backend)              Agent 2 (Frontend)           Agent 3 (Runtime)
─────────────────              ──────────────────           ──────────────────
convex/lib/costCalculator.ts   auth.ts (NextAuth config)    convex/actions/claude.ts
convex/lib/validators.ts       middleware.ts                 convex/actions/telegram.ts
convex/functions/users.ts      lib/auth.ts                  convex/actions/router.ts
convex/functions/agents.ts     lib/convex.ts                convex/http.ts
convex/functions/sessions.ts   app/providers.tsx
convex/functions/messages.ts   app/globals.css
convex/functions/channels.ts   app/layout.tsx
convex/functions/usage.ts      components/ui/* (shadcn)
convex/functions/dashboard.ts  components/layout/*
convex/functions/activeRuns.ts components/auth/AuthForm.tsx
convex/auth.ts                 components/chat/*
convex/crons.ts                components/dashboard/*
                               app/login/page.tsx
                               app/register/page.tsx
                               app/page.tsx (dashboard)
                               app/chat/page.tsx
                               app/chat/[sessionId]/page.tsx
                               app/settings/page.tsx
                               app/api/auth/register/route.ts
                               app/api/chat/route.ts
                               app/api/settings/agent/route.ts
```

### Phase 2: Integration (Sequential)

1. Agent 2 wires up API routes to Agent 1's Convex functions
2. Agent 3 wires up router.ts to call Agent 1's functions
3. Test Hub flow: login -> send message -> see response
4. Test Telegram flow: send message -> webhook -> response
5. Verify streaming works (Hub activeRuns subscription)
6. Verify usage tracking records correctly

### Dependencies Between Agents

| Agent 3 Depends On (Agent 1) | Why |
|-------------------------------|-----|
| `functions/sessions.findOrCreate` | Router needs to resolve sessions |
| `functions/messages.create` | Router stores messages |
| `functions/messages.getRecent` | Router builds context |
| `functions/agents.get` | Router reads agent config |
| `functions/usage.checkBudget` | Router checks budget before calling Claude |
| `functions/usage.record` | Router logs usage after response |
| `functions/activeRuns.*` | Router manages streaming state |
| `functions/channels.getByPlatform` | Router resolves channel for Telegram |

| Agent 2 Depends On (Agent 1) | Why |
|-------------------------------|-----|
| `functions/messages.list` | ChatWindow displays messages |
| `functions/sessions.list` | Sidebar lists conversations |
| `functions/activeRuns.get` | StreamingIndicator shows live content |
| `functions/dashboard.getStats` | Dashboard page |
| `functions/agents.get/update` | Settings page |
| `functions/usage.getTodaySummary` | Dashboard stats |

| Agent 2 Depends On (Agent 3) | Why |
|-------------------------------|-----|
| `actions/router.processSession` | API route triggers agent loop |
| `http.ts /hub/send` | Alternative trigger for agent loop |

**All agents can build simultaneously because:**
- Agent 1 writes Convex functions with known signatures (from this doc)
- Agent 2 writes frontend using `useQuery`/`useMutation` with API references that will resolve once Agent 1's code is deployed
- Agent 3 writes actions that call Agent 1's functions by reference (they'll compile once all code is in place)
- Integration testing happens after all three agents complete

---

## 8. Seed Data Script

After build, run once to set up initial data:

```typescript
// scripts/seed.ts (run via npx convex run)
// 1. Create default gateway: { name: "Personal", slug: "personal", status: "active" }
// 2. Create default agent: { name: "Synapse", slug: "synapse", model: "claude-sonnet-4-20250514", systemPrompt: "You are Synapse, a helpful AI assistant.", isActive: true }
// 3. Create hub channel: { platform: "hub", name: "Hub Chat", agentId, isActive: true, config: {} }
// 4. Create telegram channel: { platform: "telegram", name: "Telegram", agentId, isActive: true, config: { botUsername: env.TELEGRAM_BOT_USERNAME } }
// 5. Set DEFAULT_GATEWAY_ID env var to the created gateway ID
```

---

## 9. Telegram Webhook Setup

After deployment:

```bash
# Set webhook URL
curl -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/setWebhook" \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://YOUR_CONVEX_SITE_URL/webhook/telegram",
    "secret_token": "YOUR_TELEGRAM_WEBHOOK_SECRET"
  }'
```

---

## 10. Critical Rules Checklist

- [ ] Every Convex table has `gatewayId` field
- [ ] Every query/mutation validates `gatewayId` scoping
- [ ] Browser never calls Convex mutations directly (always via API routes)
- [ ] Browser CAN use `useQuery` for real-time reads (safe, read-only)
- [ ] All passwords bcrypt-hashed (cost 12)
- [ ] Telegram webhook verifies secret token header
- [ ] No em dashes in any code, comments, or UI text
- [ ] All costs calculated in USD using MODEL_COSTS constants
- [ ] activeRuns cleaned up after completion (deleted via scheduler)
- [ ] TypeScript strict mode enabled in tsconfig.json
